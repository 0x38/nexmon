
/* ********* wlc_if is part of wlc_info (as linked list) ****************** */

/* virtual interface */
struct wlc_if {
	wlc_if_t	*next;
	uint8		type;		/* WLC_IFTYPE_BSS or WLC_IFTYPE_WDS */
	uint8		index;		/* assigned in wl_add_if(), index of the wlif if any,
					 * not necessarily corresponding to bsscfg._idx or
					 * AID2PVBMAP(scb).
					 */
	uint8		flags;		/* flags for the interface */
	wl_if_t		*wlif;		/* pointer to wlif */
	struct wlc_txq_info *qi;	/* pointer to associated tx queue */
	union {
		struct scb *scb;		/* pointer to scb if WLC_IFTYPE_WDS */
		struct wlc_bsscfg *bsscfg;	/* pointer to bsscfg if WLC_IFTYPE_BSS */
	} u;
	wlc_if_stats_t	_cnt;		/* interface stats counters */
};


/* virtual interface types */
#define WLC_IFTYPE_BSS 1		/* virt interface for a bsscfg */
#define WLC_IFTYPE_WDS 2		/* virt interface for a wds */

/* flags for the interface */
#define WLC_IF_PKT_80211	0x01	/* this interface expects 80211 frames */
#define WLC_IF_LINKED		0x02	/* this interface is linked to a wl_if */
#define WLC_IF_VIRTUAL		0x04


/* TX Queue information
 * 
 * Each flow of traffic out of the device has a TX Queue with independent
 * flow control. Several interfaces may be associated with a single TX Queue
 * if they belong to the same flow of traffic from the device. For multi-channel
 * operation there are independent TX Queues for each channel.
 */
struct wlc_txq_info {
	struct wlc_txq_info *next;
	struct pktq	q;
	uint		stopped;	/* tx flow control bits */
};

/* Flags used in wlc_txq_info.stopped */
#define TXQ_STOP_FOR_PRIOFC_MASK	0x000000FF /* per prio flow control bits */
#define TXQ_STOP_FOR_PKT_DRAIN		0x00000100 /* stop txq enqueue for packet drain */
#define TXQ_STOP_FOR_AMPDU_FLOW_CNTRL	0x00000200 /* stop txq enqueue for ampdu flow control */









struct wlc_info {
	wlc_pub_t	*pub;			/* pointer to wlc public state */
	osl_t		*osh;			/* pointer to os handle */
	struct wl_info	*wl;			/* pointer to os-specific private state */
	d11regs_t	*regs;			/* pointer to device registers */

	wlc_hw_info_t	*hw;			/* HW related state used primarily by BMAC */
#ifdef WLC_SPLIT
	rpc_info_t	*rpc;			/* Handle to RPC module */
#endif

	/* clock */
	int		clkreq_override;	/* setting for clkreq for PCIE : Auto, 0, 1 */
	uint16		fastpwrup_dly;		/* time in us needed to bring up d11 fast clock */

	/* interrupt */
	uint32		macintstatus;		/* bit channel between isr and dpc */
	uint32		macintmask;		/* sw runtime master macintmask value */
	uint32		defmacintmask;		/* default "on" macintmask value */

	/* up and down */
	bool		device_present;		/* (removable) device is present */

	bool		clk;			/* core is out of reset and has clock */
	bool		watchdog_disable;	/* to disable watchdog */

	/* multiband */
	wlccore_t	*core;			/* pointer to active io core */
	wlcband_t	*band;			/* pointer to active per-band state */
	wlccore_t	*corestate;		/* per-core state (one per hw core) */
	wlcband_t	*bandstate[MAXBANDS];		/* per-band state (one per phy/radio) */

	bool		war16165;		/* PCI slow clock 16165 war flag */
	uint16		bt_shm_addr;

	bool		tx_suspended;		/* data fifos need to remain suspended */

	uint		txpend16165war;
	int8		phy_noise_list[MAXCHANNEL];	/* noise right after tx */

	/* packet queue */
	uint		qvalid;			/* DirFrmQValid and BcMcFrmQValid */

	/* BMAC_NOTE: wlc_phy code requires this */
	uint32		radar;			/* radar info: just on or off for now */

	/* Regulatory power limits */
	int8		txpwr_local_max;	/* regulatory local txpwr max */
	uint8		txpwr_local_constraint;	/* local power contraint in dB */


#ifdef WLC_HIGH

#ifdef WLC_HIGH_ONLY
	rpctx_info_t	*rpctx;			/* RPC TX module */
	bool		reset_bmac_pending;	/* bmac reset is in progressing */
	uint32		rpc_agg;		/* host agg: bit 16-31, bmac agg: bit 0-15 */
	uint32		rpc_msglevel;		/* host rpc: bit 16-31, bmac rpc: bit 0-15 */
	bool		dngl_wd_high;	        /* dngl watchdog on/off */
	uint32		dngl_wd_high_exptime;	/* dngl watchdog exptime */
#endif /* WLC_HIGH_ONLY */
	/* sub-module handler */
	wlc_seq_cmds_info_t	*seq_cmds_info;	/* pointer to sequence commands info */
#ifdef WLLED
	led_info_t	*ledh;			/* pointer to led specific information */
#endif
#ifdef CRAM
	cram_info_t	*crami;			/* cram module handler */
#endif
#ifdef WMF
	wmf_info_t	*wmfi;			/* wmf module handler */
#endif
#ifdef WLAMSDU
	amsdu_info_t	*ami;			/* amsdu module handler */
#endif
#ifdef WLBA
	ba_info_t	*bastate;		/* pointer to ba module state */
#endif
#ifdef WLAMPDU
	ampdu_info_t	*ampdu;			/* ampdu module handler */
#endif
#ifdef WOWL
	wowl_info_t	*wowl;			/* WOWL module handler */
#endif
#ifdef BCMAUTH_PSK
	wlc_auth_info_t	*authi;			/* authenticator module handler shim */
#endif
#ifdef WLP2P
	p2p_info_t	*p2p;			/* p2p module handler */
#endif
#ifdef WLMCHAN
	mchan_info_t	*mchan;			/* mchan module handler */
#endif
#ifdef WLBTAMP
	bta_info_t	*bta;			/* bta module handler */
#endif
#ifdef WLMFG
	mfg_info_t	*mfg;			/* mfg module handler */
#endif
#ifdef WLEXTLOG
	wlc_extlog_info_t *extlog;		/* extlog handler */
#endif
	antsel_info_t	*asi;			/* antsel module handler */
	wlc_cm_info_t	*cmi;			/* channel manager module handler */
	ratesel_info_t	*rsi;			/* ratesel module handler */
	wlc_cac_t	*cac;			/* CAC handler */
	wlc_scan_info_t	*scan;			/* ptr to scan state info */
	wlc_plt_pub_t	*plt;			/* plt(Production line Test) module handler */


#ifdef WET
	void		*weth;			/* pointer to wet specific information */
#endif
#ifdef WET_TUNNEL
	void		*wetth ;		/* pointer to wet tunnel specific information */
#endif
	void		*btparam;		/* bus type specific cookie */

	uint		vars_size;		/* size of vars, free vars on detach */

	uint16		vendorid;		/* PCI vendor id */
	uint16		deviceid;		/* PCI device id */
	uint		ucode_rev;		/* microcode revision */

	uint32		machwcap;		/* MAC capabilities, BMAC shadow */
	uint16		xmtfifo_szh[NFIFO];	/* fifo size in 256B for each xmt fifo */
	uint16		xmtfifo_frmmaxh[AC_COUNT];	/* max # of frames fifo size can hold */

	struct ether_addr perm_etheraddr;	/* original sprom local ethernet address */

	bool		bandlocked;		/* disable auto multi-band switching */
	bool		bandinit_pending;	/* track band init in auto band */

	bool		radio_monitor;		/* radio timer is running */
	bool		down_override;		/* true=down */
	bool		going_down;		/* down path intermediate variable */

#ifdef WLSCANCACHE
	bool		_assoc_cache_assist;	/* enable use of scan cache in assoc attempts */
#endif
	bool		mpc;			/* enable minimum power consumption */
	bool		mpc_out;		/* disable radio_mpc_disable for out */
	bool		mpc_scan;		/* disable radio_mpc_disable for scan */
	bool		mpc_join;		/* disable radio_mpc_disable for join */
	bool		mpc_oidscan;		/* disable radio_mpc_disable for oid scan */
	bool		mpc_oidjoin;		/* disable radio_mpc_disable for oid join */
	bool		mpc_oidnettype;		/* disable radio_mpc_disable for oid
						 * network_type_in_use
						 */
	uint8		mpc_dlycnt;		/* # of watchdog cnt before turn disable radio */
	uint8		mpc_offcnt;		/* # of watchdog cnt that radio is disabled */
	uint8		mpc_delay_off;		/* delay radio disable by # of watchdog cnt */

	/* timer */
	struct wl_timer *wdtimer;		/* timer for watchdog routine */
	uint		fast_timer;		/* Periodic timeout for 'fast' timer */
	uint		slow_timer;		/* Periodic timeout for 'slow' timer */
	uint		glacial_timer;		/* Periodic timeout for 'glacial' timer */
	uint		phycal_mlo;		/* last time measurelow calibration was done */
	uint		phycal_txpower;		/* last time txpower calibration was done */

	struct wl_timer *radio_timer;		/* timer for hw radio button monitor routine */
	struct wl_timer *pspoll_timer;		/* periodic pspoll timer DSLCPE? BSSCFG */

	/* promiscuous */
	uint32		monitor;		/* monitor (MPDU sniffing) mode */
	bool		bcnmisc_ibss;		/* bcns promisc mode override for IBSS */
	bool		bcnmisc_scan;		/* bcns promisc mode override for scan */
	bool		bcnmisc_monitor;	/* bcns promisc mode override for monitor */

	bool		channel_qa_active;	/* true if chan qual measurement in progress */

	uint8		bcn_wait_prd;		/* max waiting period (for beacon) in 1024TU */

	/* driver feature */
	bool		frameburst;		/* enable per-packet framebursting */
#ifdef WLAFTERBURNER
	bool		afterburner;		/* true if currently in afterburner mode */
	uint8		ab_wds_timeout;		/* afterburner capability of wds network */
	uint8		guard_count;		/* ab <--> n mode switchover guard time, secs */
	bool		ampdu_saved;		/* saved value for ab <--> n switchover */
	bool		amsdu_tx_saved;		/* saved value for ab <--> n switchover */
	int		wme_saved;		/* saved value for ab <--> n switchover */
#endif /* WLAFTERBURNER */
#ifdef WLAMSDU
	bool		_amsdu_rx;		/* true if currently amsdu deagg is enabled */
#endif
	bool		_amsdu_noack;		/* enable AMSDU no ack mode */
	bool		_rifs;			/* enable per-packet rifs */
	int32		rifs_advert;		/* RIFS mode advertisement */
	int32		rifs_mode;		/* RIFS mode in the HT Info IE */
	int8		sgi_tx;			/* sgi tx */
	bool		wet;			/* true if wireless ethernet bridging mode */
	bool		mac_spoof;		/* Original wireless ethernet, MAC Clone/Spoof */


	bool		txc;			/* true if tx header cache is currently enabled */
	bool		txc_policy;		/* 0:off 1:auto */
	bool		txc_sticky;		/* invalidate txc every second or not */
	uint32		txcgen;			/* tx header cache generation number */

	/* AP-STA synchronization, power save */
	/* These are only summary flags and used as global WAKE conditions.
	 *  Change them through accessor functions done on each BSS.
	 * - check_for_unaligned_tbtt - wlc_set_uatbtt(cfg, state)
	 * - PMpending - wlc_set_pmpending(cfg, state)
	 * - PSpoll - wlc_set_pspoll(cfg, state)
	 * - PMawakebcn - wlc_set_pmwakebcn(cfg, state)
	 */
	bool		check_for_unaligned_tbtt; /* check unaligned tbtt flag */
	bool		PMpending;		/* waiting for tx status with PM indicated set */
	bool		PMblocked;		/* block any PSPolling in PS mode, used to buffer
						 * AP traffic, also used to indicate in progress
						 * of scan, rm, etc. off home channel activity.
						 */
	bool		PSpoll;			/* whether there is an outstanding PS-Poll frame */
	bool		PMawakebcn;		/* bcn recvd during current waking state */

	bool		wake;			/* host-specified PS-mode sleep state */
#ifdef DEBUG_TBTT
	uint32		prev_TBTT;		/* TSF when last TBTT indicated */
	bool		bad_TBTT;		/* lost the race and iterated */
#endif
	uint8		bcn_li_bcn;		/* beacon listen interval in # beacons */
	uint8		bcn_li_dtim;		/* beacon listen interval in # dtims */

	bool		WDarmed;		/* watchdog timer is armed */
	uint32		WDlast;			/* last time wlc_watchdog() was called */

	/* WME */
	bool		wme_noack;		/* enable WME no-acknowledge mode */
	ac_bitmap_t	wme_dp;			/* Discard (oldest first) policy per AC */
	uint16		wme_dp2precmap;		/* Precedence map based on discard policy */
	bool		wme_apsd;		/* enable Advanced Power Save Delivery */
	ac_bitmap_t	wme_admctl;		/* bit i set if AC i under admission control */
	uint16		edcf_txop[AC_COUNT];	/* current txop for each ac */
	wme_param_ie_t	wme_param_ie;		/* WME parameter info element, which on STA
						 * contains parameters in use locally, and on
						 * AP contains parameters advertised to STA
						 * in beacons and assoc responses.
						 */
	bool		wme_prec_queuing;	/* enable/disable non-wme STA prec queuing */
#if defined(WME_PER_AC_TX_PARAMS)
	uint16		wme_max_rate[AC_COUNT]; /* In units of 512 Kbps */
#endif
	uint16		wme_retries[AC_COUNT];  /* per-AC retry limits */
	uint32		wme_maxbw_ac[AC_COUNT];	/* Max bandwidth per allowed per ac */

#ifdef WLAFTERBURNER
	int		afterburner_override;	/* -1:auto 0:off 1:forced on */
	uint8		abminrate;		/* afterburner min rate threshold */
#endif /* WLAFTERBURNER */

	int		vlan_mode;		/* OK to use 802.1Q Tags (ON, OFF, AUTO) */
	uint16		tx_prec_map;		/* Precedence map based on HW FIFO space */
	uint16		fifo2prec_map[NFIFO];	/* pointer to fifo2_prec map based on WME */

	bool		wpa_msgs;		/* enable/disable wpa indications via wlc_wpa_msg */

	/* BSS Configurations */
	wlc_bsscfg_t	*bsscfg[WLC_MAXBSSCFG];	/* set of BSS configurations, idx 0 is default and
						 * always valid
						 */
	wlc_bsscfg_t	*cfg;			/* the primary bsscfg (can be AP or STA) */
#ifdef MBSS
	struct ether_addr vether_base;		/* Base virtual MAC addr when user
						 * doesn't provide one
						 */
	uint8		cur_dtim_count;		/* current DTIM count */
	int8		hw2sw_idx[WLC_MAXBSSCFG]; /* Map from uCode index to software index */
	uint32		last_tbtt_us;		/* Timestamp of TBTT time */
	int8		beacon_bssidx;		/* Track start config to rotate order of beacons */
#if defined(WLC_HIGH) && defined(WLC_LOW)
	uint16		prq_base;		/* Base address of PRQ in shm */
	uint16		prq_rd_ptr;		/* Cached read pointer for PRQ */
#endif /* WLC_HIGH && WLC_LOW */
#endif /* MBSS */
	uint8		stas_associated;	/* count of ASSOCIATED STA bsscfgs */
	uint8		stas_connected;		/* # ASSOCIATED STA bsscfgs with valid BSSID */
	uint8		aps_associated;		/* count of UP AP bsscfgs */
	uint8		ibss_bsscfgs;		/* count of IBSS bsscfgs */
	uint8		block_datafifo;		/* prohibit posting frames to data fifos */
	bool		bcmcfifo_drain;		/* TX_BCMC_FIFO is set to drain */

	/* tx queue */
	wlc_txq_info_t	*tx_queues;		/* common TX Queue list */

	/* event */
	wlc_eventq_t 	*eventq;		/* event queue for deferred processing */

	/* security */
	wsec_key_t*	wsec_keys[WSEC_MAX_KEYS];	/* dynamic key storage */
	wsec_key_t*	wsec_def_keys[WLC_DEFAULT_KEYS];	/* default key storage */
	bool		wsec_swkeys;		/* indicates that all keys should be
						 * treated as sw keys (used for debugging)
						 */

	uint32		lifetime[AC_COUNT];	/* MSDU lifetime per AC in us */
	modulecb_t	*modulecb;
	dumpcb_t	*dumpcb_head;
	txmod_info_t	*txmod_fns;

	uint8		mimoft;			/* SIGN or 11N */
	uint8		mimo_band_bwcap;	/* bw cap per band type */
	bool		mimo_mixedmode;		/* mimo preamble type */
#ifdef WLAMPDU
	bool		ampdu_rts;		/* use RTS for every AMPDU */
#endif
	int8		txburst_limit_override; /* tx burst limit override */
	uint16		txburst_limit;		/* tx burst limit value */
	int8		cck_40txbw;		/* 11N, cck tx b/w override when in 40MHZ mode */
	int8		ofdm_40txbw;		/* 11N, ofdm tx b/w override when in 40MHZ mode */
	int8		mimo_40txbw;		/* 11N, mimo tx b/w override when in 40MHZ mode */
	ht_cap_ie_t	ht_cap;			/* HT CAP IE being advertised by this node */
	ht_add_ie_t	ht_add;			/* HT ADD IE being used by this node */
	obss_info_t	*obss;			/* OBSS Coexistance info */

	/* scb data */
	scb_module_t	*scbstate;		/* pointer to scb module state */

	uint		seckeys;		/* 54 key table shm address */
	uint		tkmickeys;		/* 12 TKIP MIC key table shm address */

	/* channel quality measure */
	int		channel_quality;	/* quality metric(0-3) of last measured channel, or
						 * -1 if in progress
						 */
	uint8		channel_qa_channel;	/* channel number of channel being evaluated */
	int8		channel_qa_sample[WLC_CHANNEL_QA_NSAMP]; /* rssi samples of background
								  * noise
								  */
	uint		channel_qa_sample_num;	/* count of samples in channel_qa_sample array */

	wlc_bss_list_t	*scan_results;
	int32		scanresults_minrssi;	/* RSSI threshold under which beacon/probe responses
						* are tossed due to weak signal
						*/
	wlc_bss_list_t	*custom_scan_results;	/* results from ioctl scan */
	uint	custom_scan_results_state;	/* see WL_SCAN_RESULTS_* states in wlioctl.h */
	uint	custom_iscan_results_state;	/* see WL_SCAN_RESULTS_* states in wlioctl.h */
#ifdef STA
	iscan_ignore_t	*iscan_ignore_list;	/* networks to ignore on subsequent iscans */
	uint	iscan_ignore_last;		/* iscan_ignore_list count from prev partial scan */
	uint	iscan_ignore_count;		/* cur number of elements in iscan_ignore_list */
	chanspec_t iscan_chanspec_last;		/* resume chan after prev partial scan */
	struct wl_timer *iscan_timer;		/* stops iscan after iscan_duration ms */
#endif /* STA */

	wlc_bss_info_t	*default_bss;		/* configured BSS parameters */

	uint16		AID;			/* association ID */
	uint16		counter;		/* per-sdu monotonically increasing counter */
	uint16		mc_fid_counter;		/* BC/MC FIFO frame ID counter */


	bool		ibss_allowed;		/* FALSE, all IBSS will be ignored during a scan
						 * and the driver will not allow the creation of
						 * an IBSS network
						 */
	bool 		ibss_coalesce_allowed;

	/* country, spect management */
	bool		awaiting_cntry_info;	/* still waiting for country ie in 802.11d mode */
	char		country_default[WLC_CNTRY_BUF_SZ];	/* saved country for leaving 802.11d
								 * auto-country mode
								 */
	char		autocountry_default[WLC_CNTRY_BUF_SZ];	/* initial country for 802.11d
								 * auto-country mode
								 */

	bool		country_list_extended;	/* JP-variants are reported through
						 * WLC_GET_COUNTRY_LIST if TRUE
						 */
#ifdef BCMDBG
	bcm_tlv_t	*country_ie_override;	/* debug override of announced Country IE */
#endif

	uint8 		pwr_constraint;
#if defined(WL_AP_TPC) && defined(WL11H)
	uint8		ap_tpc;
	uint8		ap_tpc_interval;
	uint16		ap_tpc_lm;
#endif
#if defined(WLTEST)
	uint16	tpc_rpt_override;	/* overrides for tpc report. */
#endif 

	uint16		prb_resp_timeout;	/* do not send prb resp if request older than this,
						 * 0 = disable
						 */

	wlc_rateset_t	sup_rates_override;	/* use only these rates in 11g supported rates if
						 * specifed
						 */

	/* 11a rate table direct adddress map */
	uint16		rt_dirmap_a[D11_RT_DIRMAP_SIZE];

	/* 11b rate table direct adddress map */
	uint16		rt_dirmap_b[D11_RT_DIRMAP_SIZE];

	int16	rssi_win_rfchain[WL_RSSI_ANT_MAX][WLC_RSSI_WINDOW_SZ]; /* rssi per antenna */
	uint8	rssi_win_rfchain_idx;

	chanspec_t	home_chanspec;		/* shared home chanspec */

	/* PHY parameters */
	chanspec_t	chanspec;		/* target operational channel */
	uint16		usr_fragthresh;	/* user configured fragmentation threshold */
	uint16		fragthresh[NFIFO];	/* per-fifo fragmentation thresholds */
	uint16		RTSThresh;		/* 802.11 dot11RTSThreshold */
	uint16		SRL;			/* 802.11 dot11ShortRetryLimit */
	uint16		LRL;			/* 802.11 dot11LongRetryLimit */
	uint16		SFBL;			/* Short Frame Rate Fallback Limit */
	uint16		LFBL;			/* Long Frame Rate Fallback Limit */

	/* network config */
	bool	shortslot;		/* currently using 11g ShortSlot timing */
	int8	shortslot_override;	/* 11g ShortSlot override */
	bool	ignore_bcns;		/* override: ignore non shortslot bcns in a 11g network */
	bool	interference_mode_crs;	/* aphy crs state for interference mitigation mode */
	bool	legacy_probe;		/* restricts probe requests to CCK rates */

	/* 11g/11n protections */
	wlc_protection_t *protection;

	wlc_stf_t *stf;

	pkt_cb_t	*pkt_callback;		/* tx completion callback handlers */

	uint32		txretried;		/* tx retried number in one msdu */

	uint8		nickname[32];		/* Set by vx/linux ioctls but currently unused */

	ratespec_t	bcn_rspec;		/* save bcn ratespec purpose */

#ifdef STA
	bool		IBSS_join_only;		/* don't start IBSS if not found */


	wlc_bsscfg_t	*assoc_req[WLC_MAXBSSCFG]; /* join/roam requests */

	/* association */
	uint		sta_retry_time;		/* time to retry on initial assoc failure */

	wlc_bss_list_t	*join_targets;
	uint		join_targets_last;	/* index of last target tried (next: --last) */

	/* 802.11h Quiet Period */
	wlc_quiet_t *quiet;

#ifdef WLRM
	rm_info_t	*rm_info;
#endif /* WLRM */
	/* Demodulator frequency tracking */
	bool		freqtrack;		/* Have we increased the frequency
						 * tracking bandwidth of the
						 * demodulator?
						 */
	uint		freqtrack_starttime;	/* Start time(in seconds) of the last
						 * frequency tracking attempt
						 */
	int8		freqtrack_attempts;	/* Number of times we tried to acquire
						 * beacons by increasing the freq
						 * tracking b/w
						 */
	int8		freqtrack_override;	/* Override setting from registry */

	uint8		apsd_sta_qosinfo;	/* Application-requested APSD configuration */
	/* APSD trigger */
	/* These are only summary flags and used as global WAKE conditions.
	 *  Change them through accessor functions done on each BSS.
	 * - apsd_sta_usp - wlc_set_apsd_stausp(cfg, state)
	 */
	bool		apsd_sta_usp;		/* Unscheduled Service Period in progress on STA */
	ac_bitmap_t	apsd_trigger_ac;	/* Permissible Acess Category in which APSD Null
						 * Trigger frames can be send
						 */
	bool		apsd_auto_trigger;	/* Enable/Disable APSD frame after indication in
						 * Beacon's PVB
						 */
	mbool		clkreqdisab;		/* disable clkreq for TX/RX/MAC Wake */
#endif	/* STA */

#ifdef AP
	bool		cs_scan_ini;		/* Channel Scan started flag */
	chanspec_t	chanspec_selected;	/* chan# selected by WLC_START_CHANNEL_SEL */
	chanspec_t	*scan_chanspec_list;
	int		scan_chanspec_list_size;
	int		scan_chanspec_count;
	uint	scb_timeout;		/* inactivity timeout for associated STAs */
	uint	scb_activity_time;	/* skip probe if activity during this time */
	bool	reprobe_scb;		/* to let watchdog know there are scbs to probe */
	bool	reprobe_wds;	/* to let watchdog know there are wds peers to probe */
	uint	scb_max_probe;		/* max number of probes to be conducted */
#endif	/* AP */

#ifdef WLCHANIM
	chanim_info_t *chanim_info;
#endif	/* WLCHANIM */

	bool		scbrssi;		/* per-scb rssi values */

	apps_wlc_psinfo_t *psinfo;              /* Power save nodes related state */
	wlc_ap_info_t *ap;

	uint8	htphy_membership;		/* HT PHY membership */

	/* Global txmaxmsdulifetime, global rxmaxmsdulifetime */
	uint32		txmsdulifetime;
	uint16		rxmsdulifetime;

#ifdef BRCMAPIVTW
	bool		brcm_ap_iv_tw;
	int8		brcm_ap_iv_tw_override;
#endif

#if defined(DELTASTATS)
	delta_stats_info_t *delta_stats;
#endif /* DELTASTATS */

	uint8		noise_req;		/* to manage phy noise sample requests */
	int		phynoise_chan_scan;	/* sampling target channel for scan */
	bool		_regulatory_domain;	/* 802.11d enabled? */
	uint		_spect_management;	/* 802.11h dot11SpectrumManagementRequired value */

	uint16	rfaware_lifetime;	/* RF awareness lifetime (us/1024, not ms) */
	uint32	exptime_cnt;		/* number of expired pkts since start_exptime */
	uint32	last_exptime;		/* sysuptime for last timer expiration */

	uint8	txpwr_percent;		/* power output percentage */

	uint8	ht_wsec_restriction;	/* the restriction of HT with TKIP or WEP */

#endif /* WLC_HIGH */

#ifdef MBSS
	uint8		mbss_ucidx_mask;	/* used for extracting ucidx from macaddr */
	uint32		max_ap_bss;		/* max ap bss supported by driver */
#endif /* MBSS */

	uint		bcn_thresh;		/* bcn intervals w/o bcn --> bcn lost event */
	uint		bcn_interval_cnt;	/* count of bcn intervals since last bcn */

	uint16		tx_duty_cycle_ofdm;	/* maximum allowed duty cycle for OFDM */
	uint16		tx_duty_cycle_cck;	/* maximum allowed duty cycle for CCK */

	/* pointer to LMAC realted data structure */
	lmac_info_t	*lmac_info;

	bool		nav_reset_war_disable;	/* WAR to reset NAV on 0 duration ACK */

	int		sup_wpa2_eapver;	/* for choosing eapol version in M2 */
	bool		sup_m3sec_ok;		/* to selectively allow incorrect bit in M3 */
	int		txc_scb_handle;		/* txc scb cubby offset */

	/* parameters for delaying radio shutdown after sending NULL PM=1 */
	uint16		pm2_radio_shutoff_dly;	/* configurable radio shutoff delay */
	bool		pm2_radio_shutoff_pending;	/* flag indicating radio shutoff pending */
	struct wl_timer *pm2_radio_shutoff_dly_timer;	/* timer to delay radio shutoff */

#ifdef CCA_STATS
	cca_info_t *cca_info;

#ifdef ISID_STATS
	itfr_info_t *itfr_info;
#endif /* ISID_STATS */
#endif /* CCA_STATS */

	struct sa_seqctl ctl_dup_det[SA_SEQCTL_SIZE]; /* Small table for duplicate detections
						       * for cases where SCB does not exist
						       */
	uint8 ctl_dup_det_idx;

#ifdef BCMWAPI_WPI
	uint	wapimickeys;		/* 8 WAPI MIC key table shm address */
	/* WAPI HW support variables */
	bool	hw_wapi_capable;
	bool	hw_wapi_enabled;
#endif /* BCMWAPI_WPI */

#ifdef DSLCPE_WL_IQ
	wlc_iq_info_t *dslcpe_iq;
#endif

#if defined(RWL_WIFI) || defined(WIFI_REFLECTOR)
	void *rwl;
#endif /* RWL_WIFI  || WIFI_REFLECTOR */

	uint16	next_bsscfg_ID;

	/* An unique request ID is assciated to corelate request/response-set */
	uint16	escan_sync_id;

	wlc_btc_config_t *btch;
	wlc_rrm_info_t *rrm_info;	/* 11k radio measurement info */
#ifdef WLWNM
	wlc_wnm_info_t *wnm_info;	/* 11v wireless radio management info */
#endif
	wlc_if_t	*wlcif_list;	/* linked list of wlc_if structs */
	wlc_txq_info_t	*active_queue;	/* txq for the currently active transmit context */
#ifdef WL_MULTIQUEUE
	wlc_txq_info_t *primary_queue;	/* current queue for normal (non-excursion) traffic */
	wlc_txq_info_t *excursion_queue; /* txq for excursions (scan, measurement, etc.) */
	bool excursion_active;
	bool txfifo_detach_pending;
	wlc_txq_info_t *txfifo_detach_transition_queue;
#endif /* WL_MULTIQUEUE */

#ifdef WLPFN
	void		*pfn;
#endif
	uint32		mpc_dur;		/* total time (ms) in mpc mode except for the
						 * portion since radio is turned off last time
						 */
	uint32		mpc_laston_ts;		/* timestamp (ms) when radio is turned off last
						 * time
						*/
	bool		pr80838_war;
	bool		nolinkup; 	/* suppress link up events */
	uint		hwrxoff;
	wlc_hwtimer_info_t *gptimer; /* hw gptimer for multiplexed use */
	mbool		gptimer_stay_awake_req; /* bitfield used to keep device awake
						 * if user of gptimer requires it
						 */

	/* MHF2_SKIP_ADJTSF ucode host flag manipulation */
	uint32		skip_adjtsf;	/* bitvec, IDs of users requesting to skip ucode TSF adj. */
	/* MCTL_AP maccontrol register bit manipulation */
	uint32		stop_ap;	/* bitvec, IDs of users requesting to stop the AP func. */

#ifdef STA
#if defined(AP_KEEP_ALIVE)
	uint16		keep_alive_time;
	uint16		keep_alive_count;
#endif 
	bool	reset_triggered_pmoff;		/* tells us if reset took place and turned off PM */
#endif /* STA */

#ifdef BCMDBG
	wlc_perf_stats_t perf_stats;
#endif /* BCMDBG */

#ifdef WLNINTENDO2
	wl_lq_stats_t 	_lqstats; /* Link Quality stats */
	uint			flush_txfifo_bitmap;
#endif /* WLNINTENDO2 */
	bool rpt_hitxrate;	/* report highest tx rate in history */
	bool	_autocountry;		/* autocountry enable/disable */
	bool	autocountry_adopted_from_ap;	/* whether the current locale is adopted from */
						/* country IE of a associated AP */
	uint8	roam_rssi_cancel_hysteresis;		/* Cancel ROAM RSSI Hysteresis */
	uint32  pkteng_maxlen;      /* maximum packet length */

#ifdef DSLCPE
	bool in_send_q;
#endif
};














/*
* If virtual IF in WDS mode, this could be needed
*/ 


/* station control block - one per remote MAC address */
struct scb {
	void *scb_priv;		/* internal scb data structure */
#ifdef MACOSX
	uint32 magic;
#endif
	uint32	flags;		/* various bit flags as defined below */
	uint32	flags2;		/* various bit flags2 as defined below */
	wsec_key_t	*key;		/* per station WEP key */
	wlc_bsscfg_t	*bsscfg;	/* bsscfg to which this scb belongs */
	uint8   auth_bsscfg[SCB_BSSCFG_BITSIZE]; /* authentication state w/ respect to bsscfg(s) */
	uint8	state; /* current state bitfield of auth/assoc process */
	bool		permanent;	/* scb should not be reclaimed */
	struct ether_addr ea;		/* station address */
	uint		used;		/* time of last use */
	uint32		assoctime;	/* time of association */
	uint		bandunit;	/* tha band it belongs to */
#if defined(IBSS_PEER_GROUP_KEY)
	wsec_key_t	*ibss_grp_keys[WSEC_MAX_DEFAULT_KEYS];	/* Group Keys for IBSS peer */
#endif /* defined(IBSS_PSK) */


	uint16	 WPA_auth;	/* WPA: authenticated key management */
	uint32	 wsec;	/* ucast security algo. should match key->algo. Needed before key is set */

	wlc_rateset_t	rateset;	/* operational rates for this remote station */

	void	*fragbuf[NUMPRIO];	/* defragmentation buffer per prio */
	uint	fragresid[NUMPRIO];	/* #bytes unused in frag buffer per prio */

	uint16	 seqctl[NUMPRIO];	/* seqctl of last received frame (for dups) */
	uint16	 seqctl_nonqos;		/* seqctl of last received frame (for dups) for
					 * non-QoS data and management
					 */
	uint16	 seqnum[NUMPRIO];	/* WME: driver maintained sw seqnum per priority */

	/* APSD configuration */
	struct {
		uint16		maxsplen;   /* Maximum Service Period Length from assoc req */
		ac_bitmap_t	ac_defl;    /* Bitmap of ACs enabled for APSD from assoc req */
		ac_bitmap_t	ac_trig;    /* Bitmap of ACs currently trigger-enabled */
		ac_bitmap_t	ac_delv;    /* Bitmap of ACs currently delivery-enabled */
	} apsd;

#ifdef AP
	uint16		aid;		/* association ID */
	uint8		*challenge;	/* pointer to shared key challenge info element */
	uint16		tbtt;		/* count of tbtt intervals since last ageing event */
	uint8		auth_alg;	/* 802.11 authentication mode */
	bool		PS;		/* remote STA in PS mode */
	bool            PS_pend;        /* Pending PS state */
	uint		grace_attempts;	/* Additional attempts made beyond scb_timeout
					 * before scb is removed
					 */
#endif /* AP */
	uint8		*wpaie;		/* WPA IE */
	uint		wpaie_len;	/* Length of wpaie */
	wlc_if_t	*wds;		/* per-port WDS cookie */
	int		*rssi_window;	/* rssi samples */
	int		rssi_index;
	int		rssi_enabled;	/* enable rssi collection */
	uint16		cap;		/* sta's advertized capability field */
	uint16		listen;		/* minimum # bcn's to buffer PS traffic */

	uint16		amsdu_mtu_pref;	/* preferred AMSDU mtu in bytes */
#if defined(WL_AP_TPC)
	int8		sta_link_margin;	/* STAs present link margin */
	int8		ap_link_margin;		/* APs present link margin */
#endif
#ifdef WL11N
	bool		ht_mimops_enabled;	/* cached state: a mimo ps mode is enabled */
	bool		ht_mimops_rtsmode;	/* cached state: TRUE=RTS mimo, FALSE=no mimo */
	uint16		ht_capabilities;	/* current advertised capability set */
	uint8		ht_ampdu_params;	/* current adverised AMPDU config */
	uint8		rclen;			/* regulatory class length */
	uint8		rclist[MAXRCLISTSIZE];	/* regulatory class list */
#endif /* WL11N */

	struct tx_path_node	*tx_path; /* Function chain for tx path for a pkt */
	uint32		fragtimestamp[NUMPRIO];
#ifdef WLCNTSCB
	wlc_scb_stats_t scb_stats;
#endif /* WLCNTSCB */
#ifdef BCMWAPI_WPI
	wsec_key_t	*prev_key;	/* to support key rotation per station */
	uint32		prev_key_valid_time;
#endif /* BCMWAPI_WPI */
#ifdef MFP
	bool		sa_query_started;
	uint16		sa_query_id;
	uint32		sa_query_count;  /* SA query count */
	struct wl_timer *sa_query_timer; /* SA query timer */
#endif
	bool		stale_remove;
#ifdef WLPKTDLYSTAT
	struct wlc_scb_delay_stats	delay_stats[AC_COUNT];	/* per-AC delay stats */
#endif
};




/*
* If virtual IF in BSS mode, this could be needed
*/ 




/* BSS configuration state */
struct wlc_bsscfg {
	struct wlc_info	*wlc;		/* wlc to which this bsscfg belongs to. */
	bool		up;		/* is this configuration up operational */
	bool		enable;		/* is this configuration enabled */
	bool		_ap;		/* is this configuration an AP */
	bool		associated;	/* is BSS in ASSOCIATED state */
	struct wlc_if	*wlcif;		/* virtual interface, NULL for primary bsscfg */
	void		*sup;		/* pointer to supplicant state */
	int8		sup_type;	/* type of supplicant */
	bool		sup_enable_wpa;	/* supplicant WPA on/off */
	bool		BSS;		/* infraustructure or adhac */
	bool		dtim_programmed;
	void		*authenticator;	/* pointer to authenticator state */
	bool		sup_auth_pending;	/* flag for auth timeout */
	uint8		SSID_len;	/* the length of SSID */
	uint8		SSID[DOT11_MAX_SSID_LEN];	/* SSID string */
	bool		closednet_nobcnssid;	/* hide ssid info in beacon */
	bool		closednet_nobcprbresp;	/* Don't respond to broadcast probe requests */
	bool		ap_isolate;	/* true if isolating associated STA devices */
	struct scb *bcmc_scb[MAXBANDS]; /* one bcmc_scb per band */
	int8		_idx;		/* the index of this bsscfg,
					 * assigned at wlc_bsscfg_alloc()
					 */
	/* MAC filter */
	uint		nmac;		/* # of entries on maclist array */
	int		macmode;	/* allow/deny stations on maclist array */
	struct ether_addr *maclist;	/* list of source MAC addrs to match */

	/* Multicast filter list */
	bool		allmulti;		/* enable all multicasts */
	uint		nmulticast;		/* # enabled multicast addresses */
	struct ether_addr	*multicast; 	/* ptr to list of multicast addresses */

	/* security */
	uint32		wsec;		/* wireless security bitvec */
#ifdef DSLCPE_WDSSEC
	uint32		wdswsec;	/* wireless security bitvec for WDS */
	bool		wdswsec_enable; /* enable use of wireless security bitvec for WDS */
#endif
	int16		auth;		/* 802.11 authentication: Open, Shared Key, WPA */
	int16		openshared;	/* try Open auth first, then Shared Key */
	bool		wsec_restrict;	/* drop unencrypted packets if wsec is enabled */
	bool		eap_restrict;	/* restrict data until 802.1X auth succeeds */
	uint16		WPA_auth;	/* WPA: authenticated key management */
	bool		wpa2_preauth;	/* default is TRUE, wpa_cap sets value */
#ifdef BCMWAPI_WAI
	bool		wai_restrict;	/* restrict data until WAI auth succeeds */
	bool		wai_preauth;	/* default is TRUE, wapi_cap sets value */
#endif /* BCMWAPI_WAI */
	bool		wsec_portopen;	/* indicates keys are plumbed */
	wsec_iv_t	wpa_none_txiv;	/* global txiv for WPA_NONE, tkip and aes */
	int		wsec_index;	/* 0-3: default tx key, -1: not set */
	wsec_key_t	*bss_def_keys[WLC_DEFAULT_KEYS];	/* default key storage */

#ifdef MBSS
	wlc_pkt_t	probe_template;	/* Probe response master packet, including PLCP */
#ifdef WLLPRS
	wlc_pkt_t	lprs_template;	/* Legacy probe response master packet */
	prb_ie_info_t	prb_ieinfo;	/* information of certain ies of interest */
#endif /* WLLPRS */
	bool		prb_modified;	/* Ucode version: push to shm if true */
	wlc_spt_t	*bcn_template;	/* Beacon DMA template */
	uint32		maxassoc;	/* Max associations for this bss */
	int8		_ucidx;		/* the uCode index of this bsscfg,
					 * assigned at wlc_bsscfg_up()
					 */
	uint32		mc_fifo_pkts;	/* Current number of BC/MC pkts sent to DMA queues */
	uint32		prb_ttl_us;     /* Probe rsp time to live since req. If 0, disabled */
#ifdef WLCNT
	wlc_mbss_cnt_t *cnt;		/* MBSS debug counters */
#endif
#if defined(BCMDBG_MBSS_PROFILE)
	uint32		ps_start_us;	/* When last PS (off) transition started */
	uint32		max_ps_off_us;	/* Max delay time for out-of-PS transitions */
	uint32		tot_ps_off_us;	/* Total time delay for out-of-PS transitions */
	uint32		ps_off_count;	/* Number of deferred out-of-PS transitions completed */
	bool		bcn_tx_done;	/* TX done on sw beacon */
#endif /* BCMDBG_MBSS_PROFILE */
#endif /* MBSS */

	/* TKIP countermeasures */
	bool		tkip_countermeasures;	/* flags TKIP no-assoc period */
	uint32		tk_cm_dt;	/* detect timer */
	uint32		tk_cm_bt;	/* blocking timer */
	uint32		tk_cm_bt_tmstmp;    /* Timestamp when TKIP BT is activated */
	bool		tk_cm_activate;	/* activate countermeasures after EAPOL-Key sent */
#ifdef AP
	uint8		aidmap[AIDMAPSZ];	/* aid map */
#endif
#ifdef WMF
	bool		wmf_enable;	/* WMF is enabled or not */
	bool		wmf_ucast_igmp;	/* 1 to enable, 0 by default */
	struct wlc_wmf_instance	*wmf_instance; /* WMF instance handle */
#endif
#ifdef MCAST_REGEN
	bool		mcast_regen_enable;	/* Multicast Regeneration is enabled or not */
#endif
	vndr_ie_listel_t	*vndr_ie_listp;	/* dynamic list of Vendor IEs */
	struct ether_addr	BSSID;		/* BSSID (associated) */
	struct ether_addr	cur_etheraddr;	/* h/w address */
	uint16                  bcmc_fid;	/* the last BCMC FID queued to TX_BCMC_FIFO */
	uint16                  bcmc_fid_shm;	/* the last BCMC FID written to shared mem */

	uint32		flags;		/* WLC_BSSCFG flags; see below */
#ifdef STA
	/* Association parameters. Used to limit the scan in join process. Saved before
	 * starting a join process and freed after finishing the join process regardless
	 * if the join is succeeded or failed.
	 */
	wl_join_assoc_params_t	*assoc_params;
	uint16			assoc_params_len;
#endif
	struct ether_addr	prev_BSSID;	/* MAC addr of last associated AP (BSS) */


#if defined(MACOSX)
	bool	sendup_mgmt;		/* sendup mgmt per packet filter setting */
#endif

	/* for Win7 */
	uint8		*bcn;		/* AP beacon */
	uint		bcn_len;	/* AP beacon length */
	bool		ar_disassoc;	/* disassociated in associated recreation */

	int		auth_atmptd;	/* auth type (open/shared) attempted */

	/* PMKID caching */
	pmkid_cand_t	pmkid_cand[MAXPMKID];	/* PMKID candidate list */
	uint		npmkid_cand;	/* num PMKID candidates */
	pmkid_t		pmkid[MAXPMKID];	/* PMKID cache */
	uint		npmkid;		/* num cached PMKIDs */

	wlc_bss_info_t	*target_bss;	/* BSS parms during tran. to ASSOCIATED state */
	wlc_bss_info_t	*current_bss;	/* BSS parms in ASSOCIATED state */

	wlc_assoc_t	*assoc;		/* association mangement */
	wlc_roam_t	*roam;		/* roam states */
	wlc_link_qual_t	*link;		/* link quality monitor */
	wlc_pm_st_t	*pm;		/* power management */
	bool		as_rt;		/* true if sta retry timer active */

	/* join targets sorting preference */
	wlc_join_pref_t *join_pref;
	/* Give RSSI score of APs in preferred band a boost
	 * to make them fare better instead of always preferring
	 * the band. This is maintained separately from regular
	 * join pref as no order can be imposed on this preference
	 */
	struct {
		uint8 band;
		uint8 rssi;
	} join_pref_rssi_delta;

#ifdef WLP2P
	/* p2p info */
	wlc_p2p_info_t	*p2p;
	/* p2p flags */
	uint16		p2p_flags;
	/* base TSF offset (for clock drift detect) */
	int16		tsfo_base;
	/* multiple MAC address manipulation */
	uint8		rcmta_ra_idx;		/* RCMTA idx for RA to be used for P2P */
	uint8		rcmta_bssid_idx;	/* RCMTA idx for BSSID to be used for P2P */
	/* d11 info - see 'M_P2P_BSS_BLK' in d11.h */
	uint8		d11cbi;			/* d11 SHM per BSS control block index */
	/* network parms */
	uint32		tbtt_h;			/* remote tbtt in local TSF time */
	uint32		tbtt_l;			/* remote tbtt in local TSF time */
	int32		tsfo_h;			/* TSF offset (local - remote) */
	int32		tsfo_l;			/* TSF offset (local - remote) */
	bool		p2p_bcn_offset_ok;
	bool		p2p_bcn_offset_cache;
	uint8		p2p_num_bad_bcn_offset;
	uint32		p2p_bcn_offset;
#endif /* WLP2P */
	/* BSSID entry in RCMTA, use the wsec key management infrastructure to
	 * manage the RCMTA entries.
	 */
	wsec_key_t	*rcmta;

#ifdef SMF_STATS
	wlc_smfs_info_t *smfs_info;
#endif /* SMF_STATS */
	int8	PLCPHdr_override;	/* 802.11b Preamble Type override */

	/* 'unique' ID of this bsscfg, assigned at bsscfg allocation */
	uint16		ID;

	uint		txrspecidx;		/* index into tx rate circular buffer */
	ratespec_t     	txrspec[NTXRATE][2];	/* circular buffer of prev MPDUs tx rates */

#ifdef WL_BSSCFG_TX_SUPR
	/* tx suppression handling */
	struct pktq	*psq;			/* defer queue */
	bool		tx_start_pending;	/* defer on/off */
#endif


#ifdef WLMCHAN
	wlc_mchan_context_t *chan_context;	/* chanspec context for bsscfg */
	uint16 sw_dtim_cnt;			/* dtim cnt kept upto date by sw */
	chanspec_t chanspec;			/* chanspec specified when starting AP */
	uint8 mchan_tbtt_since_bcn;		/* number of tbtt since last bcn */
#endif /* WLMCHAN */

#ifdef STA
	/* Scan parameters. Used to modify the scan parameters in join process.
	 * Saved before starting a join process and freed after finishing the join
	 * regardless if the join is succeeded or failed.
	 */
	wl_join_scan_params_t	*scan_params;
#endif

#ifdef WL11N
	/* SM PS */
	uint8	mimops_PM;
	uint8	mimops_ActionPM;
	uint8  	mimops_ActionRetry;
	bool    mimops_ActionPending;
#endif /* WL11N */

	/* 11g/11n protections */
	wlc_prot_cond_t	*prot_cond;	/* conditions */
	wlc_prot_cfg_t	*prot_cfg;	/* configurations */
	wlc_prot_to_t	*prot_to;	/* timeouts */

	/* Channel Switch Announcement */
	wlc_csa_t	*csa;


#ifdef STA
	bool wsec_buf_key_b4_m4;
	wsec_key_buf_info_t *wsec_key_buf_info;
#endif

	/* Broadcom proprietary information element */
	uint8		*brcm_ie;

#ifdef WL11U
	uint8		*iw_ie; /* 802.11u interworking(IW) IE */
#endif /* WL11U */

#ifdef MFP
	/* integrated group key stuff */
	wsec_igtk_info_t igtk;
#endif

	/* LEAVE THESE AT THE END */
#ifdef BCMDBG
	/* Rapid PM transition */
	wlc_hwtimer_to_t *rpmt_timer;
	uint32	rpmt_1_prd;
	uint32	rpmt_0_prd;
	uint8	rpmt_n_st;
#endif
	/* LEAVE THESE AT THE END */
};

/* wlc_bsscfg_t flags */
#define WLC_BSSCFG_PRESERVE     0x1		/* preserve STA association on driver down/up */
#define WLC_BSSCFG_WME_DISABLE	0x2		/* Do not advertise WME for this BSS */
#define WLC_BSSCFG_PS_OFF_TRANS	0x4		/* BSS is in transition to PS-OFF */
#define WLC_BSSCFG_SW_BCN	0x8		/* The BSS is generating beacons in SW */
#define WLC_BSSCFG_SW_PRB	0x10		/* The BSS is generating probe responses in SW */
#define WLC_BSSCFG_HW_BCN	0x20		/* The BSS is generating beacons in HW */
#define WLC_BSSCFG_HW_PRB	0x40		/* The BSS is generating probe responses in HW */
#define WLC_BSSCFG_DPT		0x80		/* The BSS is for DPT link */
#define WLC_BSSCFG_MBSS16	0x100		/* The BSS creates bcn/prbresp template for ucode */
#define WLC_BSSCFG_BTA		0x200		/* The BSS is for BTA link */
#define WLC_BSSCFG_NOBCMC	0x400		/* The BSS has no broadcast/multicast traffic */
#define WLC_BSSCFG_NOIF		0x800		/* The BSS has no OS presentation */
#define WLC_BSSCFG_11N_DISABLE	0x1000		/* Do not advertise .11n IEs for this BSS */
#define WLC_BSSCFG_P2P		0x2000		/* The BSS is for p2p link */
#define WLC_BSSCFG_11H_DISABLE	0x4000		/* Do not follow .11h rules for this BSS */
#define WLC_BSSCFG_NATIVEIF	0x8000		/* The BSS uses native OS if */
#define WLC_BSSCFG_P2P_DISC	0x10000		/* The BSS is for p2p discovery */
#define WLC_BSSCFG_TX_SUPR	0x20000		/* The BSS is in absence mode */
#define WLC_BSSCFG_SRADAR_ENAB	0x40000		/* follow special radar rules for soft/ext ap */
#define WLC_BSSCFG_DYNBCN	0x80000		/* Do not beacon if no client is associated */
#define WLC_BSSCFG_P2P_RESET	0x100000	/* reset the existing P2P bsscfg to default */
#define WLC_BSSCFG_P2P_RECREATE_BSSIDX 0x200000	/* alloc new bssid_idx in wlc_bsscfg_p2p_init */
#define WLC_BSSCFG_AP_NORADAR_CHAN 0x400000	/* disallow ap to start on radar channel */


/* Init strings for flags */
#define WLC_BSSCFG_FLAGS_STR_INIT \
	"PRESERVE_ASSOC", \
	"WME_DISABLE", \
	"PS_OFF_TRANS", \
	"SW_BCN", \
	"SW_PRB", \
	"HW_BCN", \
	"HW_PRB", \
	"DPT", \
	"MBSS16", \
	"BTA", \
	"NOBCMC", \
	"NOIF", \
	"11N_DISABLE", \
	"P2P", \
	"11H_DISABLE", \
	"NATIVEIF", \
	"P2P_DISC", \
	"TX_SUPR", \
	"SRADAR", \
	"DynBcn", \
	"P2P_RESET", \
	"P2P_RECREATE_BSSIDX", \
	"AP_NORADAR_CHAN"


